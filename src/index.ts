import { $query, $update, Record, StableBTreeMap, Vec, match, Result, nat64, ic, Opt, Principal, float64, text, $init} from 'azle';
import { v4 as uuidv4 } from 'uuid';

type Report = Record<{
    id: string;
    location: string;
    latitude: float64;
    longitude: float64;
    typeOfWaste: string;
    description: string;
    status: string;
    createdAt: nat64;
    updatedAt: Opt<nat64>;
    reporterId: string; // ID of the user who reported the incident
}>;

//user
type User = Record<{
    id: string;
    username: string;
    email: string;
    persona: Principal;
    createdAt: nat64;
    updatedAt: Opt<nat64>;
}>;

type ReportPayload = Record<{
    location:string;
    latitude: float64;
    longitude: float64;
    typeOfWaste: string;
    status: string;
    description: string;
    reporterId: string;
    // Check if it is enum or you can add status

}>

type UserPayload = Record<{
    username: string;
    email: string;
}>

type ReportResponse = Record<{
    message: string;
    pinLocation: string;
}>

// Creating instances of StableBTreeMap for the two entity type
const reportStr = new StableBTreeMap<string, Report>(0, 44, 512);
const userStr = new StableBTreeMap<string, User>(1, 44, 512);
let admin: Principal;


// Helper function that trims the input string and then checks the length
// The string is empty if true is returned, otherwise, string is a valid value
function isInvalidString(str: string): boolean {
  return str.trim().length == 0
}

 // Helper function to ensure the input id meets the format used for ids generated by uuid
 function isValidUuid(id: string): boolean {
  const regexExp = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi;
  return regexExp.test(id);
}


function validateReportPayload(payload: ReportPayload): Vec<text>{
  const errors = []
  const statusOptions = ['pending', 'in_progress', 'resolved']
  const {description,latitude,location,longitude,status,typeOfWaste} = payload; 
  if(isInvalidString(description)){
    errors.push(`Description='${description}' cannot be empty.`)
  }
  if(isInvalidString(location)){
    errors.push(`location='${location}' cannot be empty.`)
  }
  if(isInvalidString(typeOfWaste)){
    errors.push(`typeOfWaste='${typeOfWaste}' cannot be empty.`)
  }
  if(!statusOptions.includes(status)){
    errors.push(`status='${status}' can only be set to the following options: ${statusOptions.join(", ")}`)
  }
  if(!(isFinite(latitude) && Math.abs(latitude) <= 90)){
    errors.push(`latitude='${latitude}' values can only range from -90 to 90.`)
  }
  if(!(isFinite(longitude) && Math.abs(longitude) <= 180)){
    errors.push(`longitude='${longitude}' values can only range from -180 to 180.`)
  }
  return errors;
}
function validateUserPayload(payload: UserPayload): Vec<text>{
  const errors = []
  const statusOptions = ['pending', 'in_progress', 'resolved']
  const {email,username} = payload; 
  if(isInvalidString(username)){
    errors.push(`username='${username}' cannot be empty.`)
  }
  const emailRegex = /^\S+@\S+\.\S+$/;
  if (!emailRegex.test(email)){
        errors.push(`Email='${email}' is invalid.`)
    }
  return errors;
}

$init
export function init() : void {
  admin = ic.caller();
}

// CRUD Operations 
// Create a user instance 
$update;
export function addUser(payload: UserPayload): Result<text,text> {
  if(ic.caller().toString() !== admin.toString()){
    return Result.Err("Caller is not the canister's admin")
  }
  if (!userStr.isEmpty()) {
    return Result.Err(`We currently have an active user`);
  }
  let inputValidationErrors = validateUserPayload(payload)
  if(inputValidationErrors.length){
    return Result.Err(`Input validations failed. Errors=[${inputValidationErrors}].`)
  }
  const user = {
    id: uuidv4(),
    username: payload.username,
    email: payload.email,
    persona: ic.caller(),
    createdAt: ic.time(),
    updatedAt: Opt.None,
  };
  userStr.insert(user.id, user);
  return Result.Ok(`Successfully created user. The id of the user is ${user.id}`);
}
$update;
//this Function is to add a New Report 
export function createNewReport(payload: ReportPayload): Result<string,string> {
  if (!isReporter(payload.reporterId)) {
    return Result.Err(`This can only be done by the contract owner`);
  }

  let inputValidationErrors = validateReportPayload(payload);
  if(inputValidationErrors.length){
    return Result.Err(`Input validation failed. Errors=${inputValidationErrors}`);
  }
  const report = {
    id: uuidv4(),
    location: payload.location,
    latitude: payload.latitude,
    longitude: payload.longitude,
    typeOfWaste: payload.typeOfWaste,
    description: payload.description,
    status: payload.status,
    createdAt: ic.time(),
    updatedAt: Opt.None,
    reporterId: payload.reporterId,
};
  reportStr.insert(report.id, report);
  return Result.Ok(`Successfully created report with id=${report.id}`)
}
$update;
// Function to update information for Report
export function updateReport(id: string, payload: ReportPayload): Result<text,text> {
  if(!isValidUuid(id)){
    return Result.Err(`id='${id}' is not a valid uuid`)
  }

  const report = match(reportStr.get(id), {
    Some: (report) => report,
    None: () => null, // Return null instead of a string for non-existing reports
  });

  if (report) {
        if (!isReporter(report.reporterId)) {
          return Result.Err("This can only be done by the contract owner");
        }
        let inputValidationErrors = validateReportPayload(payload);
        if(inputValidationErrors.length){
          return Result.Err(`Input validation failed. Errors=${inputValidationErrors}`);
        }
        report.location = payload.location;
        report.latitude = payload.latitude;
        report.longitude = payload.longitude;
        report.typeOfWaste = payload.typeOfWaste;
        report.status = payload.status;
        report.description = payload.description;
        report.updatedAt = Opt.Some(ic.time());
        reportStr.insert(report.id, report);
        return Result.Ok(`Successfully updated report with id=${report.id}`);
    }
   else {
    return Result.Err(`Report with id ${id} not available`);
  }
}




// check if it is the correct user 
function isReporter(reportedId: string): boolean {
    const userOpt = userStr.get(reportedId);
    if ("None" in userOpt) {
      return false;
    }
    return userOpt.Some.persona.toText() === ic.caller().toText();
}

$query;
// function to extract Report by Id 
export function LocationForReportById(id: string): ReportResponse {
    return match(reportStr.get(id), {
        Some: (report) => {
            const point = `Your Report Geolocation is: ${report.longitude},${report.latitude}`
            return {
                message: `report by id = ${id} has been found`,
                pinLocation: point
            }
        },
        None: () => {
            return {
              message: `We can not find report by id = ${id}`,
              pinLocation: "Location not found"
            };
        }
    });
}

$query;
//Get all reports that have been made 
export function getAllReports(): Result<Vec<Report>, string> {
  const allReports = reportStr.values()
  return Result.Ok(allReports);
}

$query;
//search report by status
export function searchByStatus(status: string): Result<Vec<Report>, string> {
    const statusReports = reportStr.values().filter((report) => report.status.toString().toLowerCase() === status.toString().toLowerCase());
    return Result.Ok(statusReports);
}

$update;
// function to delete a Report 
export function deleteReport(id: string): Result<text,text> {
  if(!isValidUuid(id)){
    return Result.Err(`id='${id}' is not a valid uuid`)
  }
  let reportOpt = reportStr.get(id);
  if ("None" in reportOpt) {
    return Result.Err(`Report with id='${id}' not found.`);
  }
  if (!isReporter(reportOpt.Some.reporterId)) {
    return Result.Err("This can only be done by contract owner");
  }
  reportStr.remove(id);
  return Result.Ok(`Report with the : ${id} removed successfully`);
}

// Allow for the approving of the status to resolved 
$update
export function resolvedReport(id: string): Result<Report, string> {
  if(!isValidUuid(id)){
    return Result.Err(`id='${id}' is not a valid uuid`)
  }
  let reportOpt = reportStr.get(id);
  if ("None" in reportOpt) {
    return Result.Err(`Report with id='${id}' not found.`);
  }
  if (!isReporter(reportOpt.Some.reporterId)) {
    return Result.Err("This can only be done by contract owner");
  }
    return match(reportStr.get(id), {
        Some: (report) => {
            const resolvedReport: Report = { ...report, status:'resolved' };
            reportStr.insert(report.id, resolvedReport);
            return Result.Ok<Report, string>(resolvedReport);
        },
        None: () => Result.Err<Report, string>(`Report with id:${id} not found`),
    });
}


$query; 
// get all Reports made by a Reporter ie ReporterId
export function getAllReportsByReporter(reporterId: string): Result<Vec<Report>, string> {
  
  const allReporterReports = reportStr.values().filter((report) => report.reporterId.trim().toLowerCase() === reporterId.trim().toLowerCase())
  return Result.Ok(allReporterReports);
}


// Mocking the 'crypto' object for testing purposes
globalThis.crypto = {
    // @ts-ignore
    getRandomValues: () => {
      let array = new Uint8Array(32);
  
      for (let i = 0; i < array.length; i++) {
        array[i] = Math.floor(Math.random() * 256);
      }
  
      return array;
    },
  };
